<p>Rails 3.1 첫 번째 베타 버전이 릴리스 되었습니다. 이번부터 몇 차례에 걸쳐 새로운 기능을 소개하고 있습니다. 이번 에피소드에서는 환경 설정 방법에 대해 설명하고 그 다음에 새로운 기능을 간략하게 살펴 보겠습니다.</p>

<h3>Rails 3.1 설치</h3>

<p>Rails 3.1 beta gem을 설치 하기 전에 rvm을 사용하여 gemset을 만들고 설치 환경을 다른 환경에서 분리하여 Rails 3.0의 설치 환경에 영향을 주지 않도록합니다. 다음 명령을 실행하여 <code>railspre</code> gemset을 만듭니다.</p>

<pre class="terminal">$ rvm 1.9.2 @ railspre - create</pre>

<p>다음과 같이 명령을 실행하여 이 gemset 아래 Rails 베타를 설치합니다.</p>

<pre class="terminal">$ gem install rails - pre</pre>

<p>이에 따라 일부 gem 이 설치 됩니다. 모두가 올바르게 설치 되었는지 확인하기 위해 Rails 버전을 확인합니다.</p>

<pre class="terminal">$ rails - v
Rails 3.1.0.beta1</pre>

<p>이제 베타가 설치 되었기 때문에 첫 번째 Rails 3.1 응용 프로그램을 만들 수 있습니다.</p>

<pre class="terminal">$ rails new todo</pre>

<p>Rails 3.1 은 기본적으로 JavaScript 라이브러리로 jQuery를 사용합니다. Prototype을 사용하여 새 응용 프로그램을 작성하려는 경우 <code>-j</code> 옵션을 지정합니다.</p>

<pre class="terminal">$ rails new todo -j prototype</pre>

<p>새로운 응용 프로그램을 살펴보기 전에 해당 응용 프로그램 디렉토리에  <code>cd</code>하고  <code>bundle</code>를 실행 gem을 설치합니다. 설치가 완료되면 응용 프로그램의 구조를 살펴봅니다.</p>

<p>TextMate에서 보면 디렉토리 구조는 이와 같이 되어 있습니다. (여기에서는 기본 드로어 (drawer) 대신 <a href="https://github.com/jezdez/textmate-missingdrawer">MissingDrawer</a> 플러그인을 사용하여 사이드 바에 디렉토리 구조을 표시하고 있습니다.)</p>

<div class="imageWrapper">
  <img src="/system/photos/657/original/E265I01.png" width="796" height="392" alt="TextMate 에서 보여지는 Rails 3.1 의 디렉토리 구조"/>
</div>

<p>먼저 <code>Gemfile</code>를 살펴 봅니다. 내용은 다음과 같습니다.</p>

<p class="codeFilePath">/Gemfile</p>
<pre class="ruby">source 'http://rubygems.org'

gem 'rails', '3.1.0.beta1'

# Bundle edge Rails instead:
# gem 'rails',     :git =&gt; 'git://github.com/rails/rails.git'

gem 'sqlite3'

# Asset template engines
gem 'sass'
gem 'coffee-script'
gem 'uglifier'

gem 'jquery-rails'

# Use unicorn as the web server
# gem 'unicorn'

# Deploy with Capistrano
# gem 'capistrano'

# To use debugger
# gem 'ruby-debug19', :require =&gt; 'ruby-debug'

group :test do
  # Pretty printed test output
  gem 'turn', :require =&gt; false
end</pre>

<p>처음 몇 줄은 특히 놀랄만한 부분은 아니지만, 그 후에 “Asset template engines” 이라는 섹션이 등장합니다. Rails 는 이 버전에서 <a href="http://sass-lang.com/">SASS</a>와<a href="http://jashkenas.github.com/coffee-script/">CoffeeScript</a>이 기본적으로 활성화되었습니다. 이에 대해서는 향후 에피소드에서 더 자세히 살펴 보겠습니다. 이 섹션에는 응용 프로그램 production 모드에서 JavaScript 코드를 압축하는 <a href="https://github.com/lautis/uglifier">Uglifier</a>라는 gem 과 jquery-rails gem이 포함되어 있습니다. Prototype을 사용하는 경우는 이를 대신해서 prototype-rails 이 됩니다.</p>

<p>파일의 끝에는 <a href="http://rubygems.org/gems/turn">turn</a>gem에 대한 참조 정보가 있습니다. 그러면 테스트 출력을 청소하기 위한 gem으로 나중에 설명합니다.</p>

<h3>템플릿 변경 내용</h3>

<p>여기에서 가장 큰 변화는 템플릿 엔진에 의한 assets의 취급입니다. 응용 프로그램  <code>/public</code>디렉토리를 열면  <code>javascripts</code>와  <code>stylesheets</code>디렉토리가 사라 졌어요.</p>

<div class="imageWrapper">
  <img src="/system/photos/658/original/E265I02.png" width="803" height="507" alt="public 디렉토리에 javascripts와 stylesheets 디렉토리가 없습니다"/>
</div>

<p>만약 이 디렉토리가 없어졌다면, JavaScript와 CSS 코드를 어디에 두어야 할까요? 그 답은, 그들은 새로운 <code>/app/assets</code>디렉토리로 이동했습니다. <code>javascripts</code>디렉토리를 열면 <code>application.js</code>파일이 있습니다. 그러나 속을 들여다 보면 이곳은 응용 프로그램 Javascript를 두는 장소가 아니라는 것을 알 수 있습니다.</p>

<p class="codeFilePath">/app/assets/javascripts/application.js</p>
<pre class="javascript">// FIXME: Tell people that this is a manifest file, real code should go into discrete files
// FIXME: Tell people how Sprockets and CoffeeScript works
//
//= require jquery
//= require jquery_ujs
//= require_tree .</pre>

<p>이 파일은 전화 번호부처럼 사용되도록 설계 되어 있습니다. 여기에 Javascript 코드를 직접 작성하지 않고 동일한 디렉토리의 다른 파일에 작성합니다. 이것이 어떻게 작동 하는지 이해하기 위해 응용 프로그램 <code>Project</code>를위한 scaffold를 생성합니다.</p>

<pre class="terminal">$ rails g scaffold project name:string</pre>

<p>이 명령의 출력을 보면, <code>app/assets</code>디렉토리에 여러 파일이 생성 된 것을 알 수 있습니다.</p>
<pre class="terminal">      create  app/assets/stylesheets/scaffold.css.scss
      invoke  assets
      create    app/assets/javascripts/projects.js.coffee
      create    app/assets/stylesheets/projects.css.scss</pre>

<p>생성 된 파일 중 일부는 CSS 파일이 있지만 확장자는 <code>.scss</code>로 있습니다. 또한 Javascript 파일의 확장자는 <code>.coffee</code>로 있습니다. 잠시 후에 이 파일을 살펴보러갑니다만, 그 전에 데이터베이스를 이전하여 새롭게 <code>projects</code>테이블을 만듭니다.</p>

<pre class="terminal">$ rake db:migrate</pre>

<p>생성 된 SCSS 파일을 자세히 보면 표준 CSS 처럼 보이지만 끝 부분을 보면 중첩 된 규칙 등 일부 차이가있는 것을 알 수 있습니다. 이것은 SASS 고유의 기능으로, 향후에피소드에서 SASS을 소개 할 때 자세히 살펴 보겠습니다.</p>

<p class="codeFilePath">/app/assets/stylesheets/scaffold.css.scss</p>
<pre class="css">#error_explanation {
  width: 450px;
  border: 2px solid red;
  padding: 7px;
  padding-bottom: 0;
  margin-bottom: 20px;
  background-color: #f0f0f0;
  
  h2 {
    text-align: left;
    font-weight: bold;
    padding: 5px 5px 5px 15px;
    font-size: 12px;
    margin: -7px;
    margin-bottom: 0px;
    background-color: #c00;
    color: #fff;
  }
  
  ul li {
    font-size: 12px;
    list-style: square;
  }
}</pre>

<p>또 scaffold가 생성 한 것은 <code>Projects</code>의 페이지에서만 사용되는 CSS에 대한 <code>projects.css.scss</code>파일 및 javascript 위한 <code>projects.js.coffee</code>파일입니다. 이것은 단순히 추천이라는 점에 유의 하십시오. 모든 CSS와 Javascript 파일은 각각 하나의 파일에 정리하고 모든 페이지를 볼 때 로드 됩니다.</p>

<p>응용 프로그램 서버를 시작하고 projects 페이지를 열면 페이지의 소스에 그 2 개의 파일이 포함되어 있는 것을 알 수 있습니다.</p>

<pre class="html">&lt;link href="/assets/application.css" media="screen" ↵
  rel="stylesheet" type="text/css" /&gt;
&lt;script src="/assets/application.js" type="text/javascript"&gt; ↵
&lt;/script&gt;</pre>

<p>이 두 파일의 내용은 응용 프로그램의 JavaScript와 CSS 파일의 각각의 통합된 버전으로 이러한 파일의 내용은 <code>application.js</code> <code>application.css</code>파일의 <code>require</code>라인을 기반으로 합니다. 이 줄은 어떤 파일이 어떤 순서로 결합하여 파일에 추가 할지 여부를 결정합니다.</p>

<p class="codeFilePath">/ app/assets/javascripts/application.js</p>
<pre class="javascript">//= require jquery
//= require jquery_ujs
//= require_tree</pre>

<p>Rails 는 뒤에서 <a href="http://www.getsprockets.com/">Sprockets</a>를 사용하여 이를 실현하고 있습니다. Sprockets 는 응용 프로그램의 모든 Javascript 와 CSS 파일을 모아 하나의 파일 로 클라이언트에 보냅니다. 이 메커니즘을 통해 응용 프로그램에서 파일을 어떤 구성으로 배치해도 그들이 궁극적으로 하나의 파일로 결합 됩니다. production 모드에서는 파일이 축소화 되므로 최대한 효율적으로 다운로드 할 수 있습니다.</p>

<p>development 모드에서는 <code>application.js</code>와<code>application.css</code>의 각 파일은 자동으로 다시 로드되지만, production 모드에서는 CoffeeScript 과 SASS 파일은 컴파일되므로 성능 저하를 방지하기 위해 이러한 파일은 캐시됩니다.</p>

<h3>마이그레이션의 변경 사항</h3>

<p>Rails 3.1의 다른 새로운 기능을 살펴 보겠습니다. 먼저 앞의 scaffold 명령에서 생성된 데이터베이스 마이그레이션 파일입니다.</p>

<p class="codeFilePath">/db/migrate/20110511193808_create_projects.rb</p>
<pre class="ruby">class CreateProjects &lt; ActiveRecord::Migration
  def change
    create_table :projects do |t|
      t.string :name

      t.timestamps
    end
  end
end</pre>

<p>마이그레이션은 지금까지의 것과는 다릅니다. 일반적인 <code>up</code>와<code>down</code>메소드는 <code>change</code>메서드로 대체하여 하나로 up 과 down을 처리할 수 있게 되었습니다. Rails 3.1에서는 change 메서드에서 확인가능한 2가지 방법을 쓸 필요가 없어졌습니다. ActiveRecord에 유용한 기능이 더해진 것으로 마이그레이션 코드를 생성 하는 시간이 줄어 듭니다.</p>

<h3>Identity Map</h3>

<p>Identity Map은 ActiveRecord에 추가된 또 다른 뛰어난 기능입니다. 설정 파일 <code>application.rb</code>를 보면 기본적으로 활성화되어 있는 것을 알 수 있습니다.</p>

<p class="codeFilePath">/config/application.rb</p>
<pre class="ruby"># Enable IdentityMap for Active Record, ↵
to disable set to false or remove the line below.
config.active_record.identity_map = true</pre>

<p>Rails 3.1 첫 번째 베타 버전에서 이 기능을 실행하기 위해서 이 설정 파일을 조금 만져 코드를 한 줄 추가합니다.</p>

<p class="codeFilePath">/config/application.rb</p>
<pre class="ruby"># Enable IdentityMap for Active Record, ↵
to disable set to false or remove the line below.
config.active_record.identity_map = true
ActiveRecord::IdentityMap.enabled = true</pre>

<p>IdentityMap 기능을 통해 무엇을 할 수 있을까요? 실례로 설명하기 위해 콘솔에서 사용합니다. 먼저 새 <code>Project</code>를 만듭니다.</p>

<pre class="terminal">&gt; p = Project.create!(:name =&gt; "Yardwork")
  SQL (81.4ms)  INSERT INTO "projects" ("created_at", "name", "updated_at") VALUES (?, ?, ?)  [["created_at", Fri, 13 May 2011 18:41:25 UTC +00:00], ["name", "Yardwork"], ["updated_at", Fri, 13 May 2011 18:41:25 UTC +00:00]]
 =&gt; #&lt;Project id: 1, name: "Yardwork", created_at: "2011-05-13 18:41:25", updated_at: "2011-05-13 18:41:25"&gt;</pre> 
 
<p>우선 여기에서는 로그가 직접 콘솔에 표시 되기 때문에 명령이 실행 된 경우 어떤 SQL 이 실행 되고 있는지를 알 수 있습니다.</p>

<p>새로 생성한 <code>Project</code>를 <code>id</code>를 사용하여 제거합니다.</p>
<pre class="terminal">ruby-1.9.2-p180 :002 &gt; p1 = Project.find(1)
  Project Loaded  From Identity Map (id: 1)
 =&gt; #&lt;Project id: 1, name: "Yardwork", created_at: "2011-05-13 18:41:25", updated_at: "2011-05-13 18:41:25"&gt;</pre> 
 
<p>콘솔에는 <code>Project Loaded From Identity Map (id: 1)</code>로 표시 되어 있습니다. 데이터베이스에서 project를 만회하기 위하여 SQL 쿼리 는 실행 되지 않습니다. 그 project가 이미 메모리에 로드 되어 있는지 Rails가 알고 있고 그 인스턴스를 사용 하기 때문입니다. 이를 확인 하기 위해 두 Project의 <code>object_id</code>가 같은지 여부를 확인합니다.</p>

<pre class="terminal">ruby-1.9.2-p180 :006 &gt; p.object_id == p1.object_id
 =&gt; true</pre>
 
<p>즉, 레코드에 대한 속성을 설정하면서 그것이 연결을 통해 가져온 레코드와 동일하다고 생각하고 문제가 없다는 것입니다. 그것은 동일한 인스턴스인 것이 보증되어 있기 때문입니다.</p>

<h3>중첩된 has_many :through 연결</h3>

<p>그 밖에도 일부 ActiveRecord에 추가 된 기능이 있습니다, 그 중의 하나가 중첩된 <code>has_many :through</code> 관계입니다. 다음 모델의 코드를 보아주시기 바랍니다.</p>

<p class="codeFilePath">/app/models/project.rb</p>
<pre class="ruby">class Project &lt; ActiveRecord::Base
  has_many :tasks
  has_many :assignments, :through =&gt; :tasks
  has_many :users, :through =&gt; :assignments
end</pre>

<p>Rails의 이전 버전에서는 이러할 수 없습니다만 3.1에서는 <code>has_many :through</code>연결을 중첩할 수 있게 되었기 때문에, 유용한 상황이 많을 것입니다.</p>

<p>또 다른 새로운 기능으로 <code>attr_accessible</code>호출에 역할을 할당할 수있게 되었습니다. 예를 들어, <code>name</code>속성을 사용가능하게 설정 하면 admin 역할을 가진 사용자로 제한 할 수 있게 되었습니다.</p>

<p class="codeFilePath">/app/models/project.rb</p>
<pre class="ruby">class Project &lt; ActiveRecord::Base
  attr_accessible :name, :as =&gt; :admin
end</pre>

<p>콘솔에서 만든 <code>Project</code>에 대해 브라우저에서 필드 이름을 정원가꾸기(Yardwork) 에서 집안일( Housework) 로 변경하려고 해도, admin으로 로그인 하지 않은 상태이기 때문에 변경할 수 없습니다.</p>

<div class="imageWrapper">
  <img src="/system/photos/659/original/E265I03.png" width="801" height="280" alt="적절한 역할을 가지고 있지 않기 때문에 변경할 수 없다"/>
</div>

<p> <code>:as</code>옵션을 사용하여 <code>update_attributes</code>호출을 수정하여 컨트롤러를 통해 역할을 전달합니다.</p>

<p class="codeFilePath">/app/controllers/projects_controller.rb</p>
<pre class="ruby">def update
  @project = Project.find(params[:id])

  respond_to do |format|
    if @project.update_attributes(params[:project], :as =&gt; :admin)
      format.html { redirect_to @project, notice: 'Project ↵
          was successfully updated.' }
      format.json { head :ok }
    else
      format.html { render action: "edit" }
      format.json { render json: @project.errors, ↵           
        status: :unprocessable_entity }
    end
  end
end</pre>

<p>입력한 폼으로<code>Project</code>를 업데이트하려고 하면 이번에는 admin 역할을가지고 있기 때문에 성공합니다.</p>

<h3>뷰 계층의 변경 사항</h3>

<p>마지막으로 뷰 계층의 변경 사항을 소개합니다. 첫째는 작지만 유용한 기능 입니다. 기존 폼에 <code>file_field</code>가 있다면, 업로드된 파일이 제대로 전송 되도록 <code>form_for</code>に<code>:html =&gt; { :multipart =&gt; :true }</code>을 추가 해야 했습니다. Rails 3.1에서는 이러한 제한이 없으며 양식에 <code>file_field</code>가 포함 된 경우 <code>form</code>태그에 적절한 <code>enctype</code>속성을 추가하는 형태가 되었습니다.</p>

<p>또한 링크의 변경입니다. URL 도우미 도메인 및 하위 도메인 옵션을 전달할 수 있었습니다. 예를 들어 링크로 다음과 같은 코드가 있다고합니다.</p>

<pre class="ruby">&lt;%= link_to 'Edit', edit_project_path(@project) %&gt;</pre>

<p>이 편집 화면에 링크에서 다른 하위 도메인을 지정하려면 이 코드를 다음과 같이 바꿀 수 있습니다.</p>
<pre class="ruby">&lt;%= link_to 'Edit', edit_project_url(@project, ↵
  :subdomain =&gt; 'foo') %&gt;</pre>

<p>이제 링크는 <code>foo</code>하위 도메인의 같은 페이지를 지정할 수 있습니다.</p>

<h3>보기 쉬워진 시험 출력</h3>

<p>마지막으로 향상된 테스트 출력을 보고 있습니다. <code>rake test</code>를 실행하면 이전에 <code>Gemfile</code>에서 본 turn gem을 사용하여 출력이 정리되어 보기 쉬워졌습니다.</p>

<pre class="terminal">$ rake test
(in /Users/eifion/todo)
Loaded suite /Users/eifion/.rvm/gems/ruby-1.9.2-p180@global/gems/rake-0.8.7/lib/rake/rake_test_loader
Started

Finished in 0.003966 seconds.

0 tests, 0 assertions, 0 failures, 0 errors, 0 skips
Loaded suite /Users/eifion/.rvm/gems/ruby-1.9.2-p180@global/gems/rake-0.8.7/lib/rake/rake_test_loader
Started

ProjectsControllerTest:
     PASS should create project (0.16s) 
     PASS should destroy project (0.01s) 
     PASS should get edit (0.08s) 
     PASS should get index (0.01s) 
     PASS should get new (0.01s) 
     PASS should show project (0.01s) 
     PASS should update project (0.01s) 

Finished in 0.307078 seconds.

7 tests, 10 assertions, 0 failures, 0 errors, 0 skips</pre>

<p>Rails 3.1은 아직 여기에서 적을 수 없었던 새로운 기능이 더 많이 있습니다. 자동 스트리밍, 뷰 상속, 마운트가능한 엔진과 다른 새로운 기능들이 향후 에피소드에서 소개하고 있습니다.</p>

<p>Rails 3.1의 변경 사항의 전체 목록은 여기 <a href="https://gist.github.com/958283">소개 페이지</a>에 게재되어 있으므로 참조하십시오.</p>